# -*- coding: utf-8 -*-
"""Lab4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A144DUsviATsVlnCP7k1yKNNf-TLBK4c
"""

import pandas as pd
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import numpy as np
from sklearn import metrics
import seaborn as sns

"""ЗАГРУЗКА И ОБРАБОТКА ДАННЫХ

"""

# Загружаем данные и обрабатываем их
ds = pd.read_csv('Spotify_Youtube.csv')
url_cols = ['Url_spotify', 'Uri', 'Url_youtube', 'Title', 'Description', 'Unnamed: 0']
ds.drop(url_cols, axis=1, inplace=True)

ds = ds.drop_duplicates()

ds.head(10)

ds.dropna(inplace=True)
ds.info()

columns=['Artist','Track', 'Album', 'Album_type', 'Key', 'Channel', 'Comments','Licensed', 'official_video']
ds.drop(columns, axis=1, inplace=True)
ds.describe()

"""ДИАГРАММЫ РАССЕИВАНИЯ"""

sns.scatterplot(data = ds, x = "Views", y = "Likes")

sns.scatterplot(data = ds, x ="Loudness", y = "Energy")

sns.scatterplot(data = ds, x = "Acousticness", y = "Loudness")

sns.scatterplot(data = ds, x = "Tempo", y = "Danceability")

sns.scatterplot(data = ds, x = "Danceability", y = "Energy")

"""ГИСТОГРАММА"""

sns.histplot(data = ds, x = "Energy", bins = 100)

sns.histplot(data = ds, x = "Danceability", bins = 100)

sns.histplot(data = ds, x = "Loudness", bins = 50)

sns.histplot(data = ds, x = "Tempo", bins = 30)

"""Ящик с усами"""

sns.boxplot (data = ds, x = "Danceability")

"""НОРМАЛИЗАЦИЯ"""

ML_DF = ds[['Danceability', 'Energy', 'Loudness', 'Speechiness', 'Acousticness', 'Instrumentalness', 'Liveness', 'Valence',
              'Tempo', 'Duration_ms', 'Views', 'Likes', 'Stream']]


#Нормализация
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
scaled_ds = scaler.fit_transform(ML_DF)
scaled_ds =pd.DataFrame(scaled_ds,columns=['Danceability', 'Energy', 'Loudness', 'Speechiness', 'Acousticness', 'Instrumentalness', 'Liveness', 'Valence',
              'Tempo', 'Duration_ms', 'Views', 'Likes', 'Stream'])

scaled_ds.describe()

plt.hist(scaled_ds["Danceability"], bins=120, range=(0.0,1))
plt.title("Danceability")

sns.histplot(data = scaled_ds, x = "Danceability", bins = 100)

sns.histplot(data = scaled_ds, x = "Energy", bins = 100)

plt.hist(scaled_ds["Stream"], bins=120, range=(0.0,1))

def show_graphics(y_test, y_pred):
    plt.figure(figsize=(100, 20))
    print("\n\nGraphic: ")
    x_ax = range(len(y_test))
    plt.plot(x_ax, y_test, label='original')
    plt.plot(x_ax, y_pred, label='predicted')
    plt.title("Boston test and predicted data")
    plt.xlabel("X-axis")
    plt.ylabel("Y-axis")
    plt.legend(loc='best', fancybox=True, shadow=True)
    plt.grid(True)
    plt.show()

"""ЛИНЕЙНАЯ РЕГРЕССИЯ"""

scaled_ds.info()

attr = ["Danceability", "Energy", "Loudness", "Speechiness", "Acousticness", "Instrumentalness", "Liveness", "Valence", "Tempo", "Duration_ms", "Views", "Likes"]
X = scaled_ds[attr]
Y = ds['Stream']

from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split(X,Y, test_size = 0.1, random_state = 42)

from sklearn.linear_model import LinearRegression
model = LinearRegression()

# обучение на тренировочной выборке
model.fit(X_train, Y_train)

# прогноз по тестовой выборке
Y_pred = model.predict(X_train)

#выведем полученные коэффициенты для наших признаков
coef = pd.DataFrame([X_train.columns, model.coef_]).T
coef = coef.rename (columns = {0:"Attribute", 1 : "Coefficient"})
print(coef)

#выведем результаты
train_score_lr = model.score(X_train, Y_train)
#test_score_lr = model.score(X_test, Y_test)
print("The train score for lr model is {}".format(train_score_lr))
#print("The test score for lr model is {}".format(test_score_lr))

#чуть визуализации
show_graphics(Y_train, Y_pred)

plt.scatter(Y_train, Y_pred)
plt.xlabel("Streams")
plt.ylabel("Predicted Streams")
plt.title("Streams vs Predicted Streams")
plt.show()

"""Также важной частью работы является проверка остатков. Остаток - это
разность между ценой фактической и предсказанной.
Хорошая модель должна всегда иметь только случайные ошибки, то есть она
хорошо соответствует данным, если различия между наблюдениями и
прогнозируемыми значениями невелики и непредвзяты. Непредвзятость в
данном контексте означает, что предсказанные значения систематически не
являются слишком высокими или слишком низкими где-либо в пространстве
наблюдения.Если модель предвзята, нельзя доверять результатам.
"""

#проверка остатков
plt.scatter(Y_pred, abs(Y_pred-Y_train))
plt.title("Predicted vs residuals")
plt.xlabel("Predicted")
plt.ylabel("Residuals")
plt.show()

"""По риснку видно, что четкой зависимости в остатках нет, соответственно
наша модель имеет право на существование.
Дальше предсказывались тестовые данные и также выводились оценки
точности результатов
"""

plt.figure(figsize=(20, 9))
attr = ["Danceability", "Energy", "Loudness", "Speechiness", "Acousticness", "Instrumentalness", "Liveness", "Valence", "Tempo", "Duration_ms", "Views", "Likes"]
plt.subplot(3, 3, 1)
plt.scatter(X_train["Danceability"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Danceability"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Danceability')
plt.ylabel('Stream')
plt.subplot(3, 3, 2)
plt.scatter(X_train["Energy"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Energy"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Energy')
plt.ylabel('Stream')
plt.subplot(3, 3, 3)
plt.scatter(X_train["Loudness"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Loudness"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Loudness')
plt.ylabel('Stream')
plt.subplot(3, 3, 4)
plt.scatter(X_train['Speechiness'], Y_train, label='Actual Values', s=10)
plt.scatter(X_train['Speechiness'], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Speechiness')
plt.ylabel('Stream')
plt.subplot(3, 3, 5)
plt.scatter(X_train["Acousticness"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Acousticness"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Acousticness')
plt.ylabel('Stream')
plt.subplot(3, 3, 6)
plt.scatter(X_train["Instrumentalness"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Instrumentalness"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Instrumentalness')
plt.ylabel('Stream')
plt.legend()

plt.figure(figsize=(20, 9))
plt.subplot(3, 3, 1)
plt.scatter(X_train["Liveness"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Liveness"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Liveness')
plt.ylabel('Stream')
plt.subplot(3, 3, 2)
plt.scatter(X_train["Valence"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Valence"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Valence')
plt.ylabel('Stream')
plt.subplot(3, 3, 3)
plt.scatter(X_train["Tempo"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Tempo"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Tempo')
plt.ylabel('Stream')
plt.subplot(3, 3, 4)
plt.scatter(X_train["Duration_ms"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Duration_ms"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Duration_ms')
plt.ylabel('Stream')
plt.subplot(3, 3, 5)
plt.scatter(X_train["Views"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Views"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Views')
plt.ylabel('Stream')
plt.subplot(3, 3, 6)
plt.scatter(X_train["Likes"], Y_train, label='Actual Values', s=10)
plt.scatter(X_train["Likes"], Y_pred, label='Predicted Values', s=5)
plt.xlabel('Likes')
plt.ylabel('Stream')

Y_test_pred = model.predict(X_test)

#оценка модели
R2_score = metrics.r2_score(Y_test, Y_test_pred)
print("LINEAR REGRESSION METRICS")
print("R^2: ", R2_score)
print("MAE: ", metrics.mean_absolute_error(Y_test, Y_test_pred))
print("MSE: ", metrics.mean_squared_error(Y_test, Y_test_pred))
print("RMSE: ", np.sqrt(metrics.mean_squared_error(Y_test, Y_test_pred)))

#визуализация
plt.scatter(Y_test, Y_test_pred)
plt.xlabel("Streams")
plt.ylabel("Predicted Streams")
plt.title("Streams vs Predicted Streams")
plt.show()

#проверка остатков
plt.scatter(Y_test_pred, abs(Y_test_pred-Y_test))
plt.title("Predicted vs residuals")
plt.xlabel("Predicted")
plt.ylabel("Residuals")
plt.show()

plt.figure(figsize=(20, 9))
attr = ["Danceability", "Energy", "Loudness", "Speechiness", "Acousticness", "Instrumentalness", "Liveness", "Valence", "Tempo", "Duration_ms", "Views", "Likes"]
plt.subplot(3, 3, 1)
plt.scatter(X_test["Danceability"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Danceability"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Danceability')
plt.ylabel('Stream')
plt.subplot(3, 3, 2)
plt.scatter(X_test["Energy"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Energy"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Energy')
plt.ylabel('Stream')
plt.subplot(3, 3, 3)
plt.scatter(X_test["Loudness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Loudness"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Loudness')
plt.ylabel('Stream')
plt.subplot(3, 3, 4)
plt.scatter(X_test['Speechiness'], Y_test, label='Actual Values', s=10)
plt.scatter(X_test['Speechiness'], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Speechiness')
plt.ylabel('Stream')
plt.subplot(3, 3, 5)
plt.scatter(X_test["Acousticness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Acousticness"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Acousticness')
plt.ylabel('Stream')
plt.subplot(3, 3, 6)
plt.scatter(X_test["Instrumentalness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Instrumentalness"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Instrumentalness')
plt.ylabel('Stream')
plt.legend()

plt.figure(figsize=(20, 9))
plt.subplot(3, 3, 1)
plt.scatter(X_test["Liveness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Liveness"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Liveness')
plt.ylabel('Stream')
plt.subplot(3, 3, 2)
plt.scatter(X_test["Valence"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Valence"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Valence')
plt.ylabel('Stream')
plt.subplot(3, 3, 3)
plt.scatter(X_test["Tempo"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Tempo"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Tempo')
plt.ylabel('Stream')
plt.subplot(3, 3, 4)
plt.scatter(X_test["Duration_ms"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Duration_ms"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Duration_ms')
plt.ylabel('Stream')
plt.subplot(3, 3, 5)
plt.scatter(X_test["Views"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Views"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Views')
plt.ylabel('Stream')
plt.subplot(3, 3, 6)
plt.scatter(X_test["Likes"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Likes"], Y_test_pred, label='Predicted Values', s=5)
plt.xlabel('Likes')
plt.ylabel('Stream')

#чуть визуализации
show_graphics(Y_test, Y_test_pred)

import scipy.stats as stats
#find Q1, Q3, and interquartile range for each column
Q1 = scaled_ds.quantile(q=.25)
Q3 = scaled_ds.quantile(q=.75)
IQR = scaled_ds.apply(stats.iqr)

#only keep rows in dataframe that have values within 1.5\*IQR of Q1 and Q3
data_clean = scaled_ds[~((scaled_ds < (Q1-1.5*IQR)) | (scaled_ds > (Q3+1.5*IQR))).any(axis=1)]
data_clean = pd.DataFrame(data_clean,columns=['Danceability', 'Energy', 'Loudness', 'Speechiness', 'Acousticness', 'Instrumentalness', 'Liveness', 'Valence',
              'Tempo', 'Duration_ms', 'Views', 'Likes', 'Stream'])
data_clean.info()
scaled_ds.info()

"""LASSO"""

from sklearn.linear_model import Lasso
from sklearn.metrics import mean_squared_error
lambda1_values = [0.000001, 0.0001, 0.001, 0.005, 0.01, 0.05,  0.1, 0.2, 0.3, 0.4, 0.5, 1, 2, 5, 10, 100]# список коэффициента регуляризации 1
for lambda_val in lambda1_values:
    # для каждого коэффициента регуляризации создаем модель Lasso
    lasso_reg = Lasso(lambda_val)
    # обучение на тренировочной выборке
    lasso_reg.fit(X_train, Y_train)
    # прогноз
    Y_pred__ = lasso_reg.predict(X_test)
    # средняя квадратичная ошибка
    mse_lasso = mean_squared_error(Y_pred__, Y_test)
    print(("Lasso MSE with Lambda={} is {}").format(lambda_val, mse_lasso))

"""Меньше всего ошибка достигается при Lambda = 0.000001"""

lasso_reg = Lasso(0.000001)
Y_pred_LAS = lasso_reg.fit(X_train, Y_train)
Y_pred_LAS = lasso_reg.predict(X_test)

#выведем полученные коэффициенты для наших признаков
lasso_coef = pd.DataFrame([X_train.columns, lasso_reg.coef_]).T
lasso_coef = lasso_coef.rename (columns = {0:"Attribute", 1 : "Coefficient"})
print(lasso_coef)

#визуализация
plt.scatter(Y_test, Y_pred_LAS)
plt.xlabel("Streams")
plt.ylabel("Predicted Streams")
plt.title("Streams vs Predicted Streams")
plt.show()

#проверка остатков
plt.scatter(Y_pred_LAS, abs(Y_pred_LAS-Y_test))
plt.title("Predicted vs residuals")
plt.xlabel("Predicted")
plt.ylabel("Residuals")
plt.show()

#оценка модели
R2_score = metrics.r2_score(Y_test, Y_pred_LAS)
print("LASSO REGRESSION METRICS")
print("R^2: ", R2_score)
print("MAE: ", metrics.mean_absolute_error(Y_test, Y_pred_LAS))
print("MSE: ", metrics.mean_squared_error(Y_test, Y_pred_LAS))
print("RMSE: ", np.sqrt(metrics.mean_squared_error(Y_test, Y_pred_LAS)))

#чуть визуализации
show_graphics(Y_test, Y_pred_LAS)

plt.figure(figsize=(20, 9))
attr = ["Danceability", "Energy", "Loudness", "Speechiness", "Acousticness", "Instrumentalness", "Liveness", "Valence", "Tempo", "Duration_ms", "Views", "Likes"]
plt.subplot(3, 3, 1)
plt.scatter(X_test["Danceability"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Danceability"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Danceability')
plt.ylabel('Stream')
plt.subplot(3, 3, 2)
plt.scatter(X_test["Energy"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Energy"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Energy')
plt.ylabel('Stream')
plt.subplot(3, 3, 3)
plt.scatter(X_test["Loudness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Loudness"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Loudness')
plt.ylabel('Stream')
plt.subplot(3, 3, 4)
plt.scatter(X_test['Speechiness'], Y_test, label='Actual Values', s=10)
plt.scatter(X_test['Speechiness'], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Speechiness')
plt.ylabel('Stream')
plt.subplot(3, 3, 5)
plt.scatter(X_test["Acousticness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Acousticness"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Acousticness')
plt.ylabel('Stream')
plt.subplot(3, 3, 6)
plt.scatter(X_test["Instrumentalness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Instrumentalness"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Instrumentalness')
plt.ylabel('Stream')
plt.legend()

plt.figure(figsize=(20, 9))
plt.subplot(3, 3, 1)
plt.scatter(X_test["Liveness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Liveness"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Liveness')
plt.ylabel('Stream')
plt.subplot(3, 3, 2)
plt.scatter(X_test["Valence"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Valence"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Valence')
plt.ylabel('Stream')
plt.subplot(3, 3, 3)
plt.scatter(X_test["Tempo"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Tempo"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Tempo')
plt.ylabel('Stream')
plt.subplot(3, 3, 4)
plt.scatter(X_test["Duration_ms"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Duration_ms"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Duration_ms')
plt.ylabel('Stream')
plt.subplot(3, 3, 5)
plt.scatter(X_test["Views"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Views"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Views')
plt.ylabel('Stream')
plt.subplot(3, 3, 6)
plt.scatter(X_test["Likes"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Likes"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Likes')
plt.ylabel('Stream')
plt.legend()

"""RIDGE"""

from sklearn.linear_model import Ridge

lambda2_values = [0.000001, 0.0001, 0.001, 0.005, 0.01, 0.05,  0.1, 0.2, 0.3, 0.4, 0.5, 1, 2, 2.13, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 10, 100]# список коэффициента регуляризации 2


for lambda_val in lambda2_values:
    # для каждого коэффициента регуляризации создаем модель Ridge
    ridge_reg = Ridge(lambda_val)

    ridge_reg.fit(X_train, Y_train)
    y_pred = ridge_reg.predict(X_test)
    mse_ridge = mean_squared_error(y_pred, Y_test)
    print(("Lasso MSE with Lambda={} is {}").format(lambda_val, mse_ridge))

"""Самая маленькая средняя квадратичная ошибка при Lambda = 2"""

ridge_reg = Ridge(2)
Y_pred_Ridge = ridge_reg.fit(X_train, Y_train)
Y_pred_Ridge = ridge_reg.predict(X_test)
#выведем полученные коэффициенты для наших признаков
ridge_coef = pd.DataFrame([X_train.columns, ridge_reg.coef_]).T
ridge_coef = ridge_coef.rename (columns = {0:"Attribute", 1 : "Coefficient"})
print(ridge_coef)

#визуализация
plt.scatter(Y_test, Y_pred_Ridge)
plt.xlabel("Streams")
plt.ylabel("Predicted Streams")
plt.title("Streams vs Predicted Streams")
plt.show()

#проверка остатков
plt.scatter(Y_pred_Ridge, abs(Y_pred_Ridge-Y_test))
plt.title("Predicted vs residuals")
plt.xlabel("Predicted")
plt.ylabel("Residuals")
plt.show()

#оценка модели
R2_score = metrics.r2_score(Y_test, Y_pred_Ridge)
print("RIDGE REGRESSION METRICS")
print("R^2: ", R2_score)
print("MAE: ", metrics.mean_absolute_error(Y_test, Y_pred_Ridge))
print("MSE: ", metrics.mean_squared_error(Y_test, Y_pred_Ridge))
print("RMSE: ", np.sqrt(metrics.mean_squared_error(Y_test, Y_pred_Ridge)))

plt.figure(figsize=(20, 9))
attr = ["Danceability", "Energy", "Loudness", "Speechiness", "Acousticness", "Instrumentalness", "Liveness", "Valence", "Tempo", "Duration_ms", "Views", "Likes"]
plt.subplot(3, 3, 1)
plt.scatter(X_test["Danceability"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Danceability"], Y_pred_Ridge, label='Predicted Values', s=5)
plt.xlabel('Danceability')
plt.ylabel('Stream')
plt.subplot(3, 3, 2)
plt.scatter(X_test["Energy"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Energy"], Y_pred_Ridge, label='Predicted Values', s=5)
plt.xlabel('Energy')
plt.ylabel('Stream')
plt.subplot(3, 3, 3)
plt.scatter(X_test["Loudness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Loudness"], Y_pred_Ridge, label='Predicted Values', s=5)
plt.xlabel('Loudness')
plt.ylabel('Stream')
plt.subplot(3, 3, 4)
plt.scatter(X_test['Speechiness'], Y_test, label='Actual Values', s=10)
plt.scatter(X_test['Speechiness'], Y_pred_Ridge, label='Predicted Values', s=5)
plt.xlabel('Speechiness')
plt.ylabel('Stream')
plt.subplot(3, 3, 5)
plt.scatter(X_test["Acousticness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Acousticness"], Y_pred_Ridge, label='Predicted Values', s=5)
plt.xlabel('Acousticness')
plt.ylabel('Stream')
plt.subplot(3, 3, 6)
plt.scatter(X_test["Instrumentalness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Instrumentalness"], Y_pred_Ridge, label='Predicted Values', s=5)
plt.xlabel('Instrumentalness')
plt.ylabel('Stream')
plt.legend()

plt.figure(figsize=(20, 9))
plt.subplot(3, 3, 1)
plt.scatter(X_test["Liveness"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Liveness"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Liveness')
plt.ylabel('Stream')
plt.subplot(3, 3, 2)
plt.scatter(X_test["Valence"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Valence"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Valence')
plt.ylabel('Stream')
plt.subplot(3, 3, 3)
plt.scatter(X_test["Tempo"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Tempo"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Tempo')
plt.ylabel('Stream')
plt.subplot(3, 3, 4)
plt.scatter(X_test["Duration_ms"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Duration_ms"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Duration_ms')
plt.ylabel('Stream')
plt.subplot(3, 3, 5)
plt.scatter(X_test["Views"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Views"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Views')
plt.ylabel('Stream')
plt.subplot(3, 3, 6)
plt.scatter(X_test["Likes"], Y_test, label='Actual Values', s=10)
plt.scatter(X_test["Likes"], Y_pred_LAS, label='Predicted Values', s=5)
plt.xlabel('Likes')
plt.ylabel('Stream')
plt.legend()
plt.legend()

#чуть визуализации
show_graphics(Y_test, Y_pred_LAS)

#вывод всех оценок моделей
R2_score = metrics.r2_score(Y_test, Y_test_pred)
print("LINEAR REGRESSION METRICS")
print("R^2: ", R2_score)
print("MAE: ", metrics.mean_absolute_error(Y_test, Y_test_pred))
print("MSE: ", metrics.mean_squared_error(Y_test, Y_test_pred))
print("RMSE: ", np.sqrt(metrics.mean_squared_error(Y_test, Y_test_pred)))

R2_score = metrics.r2_score(Y_test, Y_pred_LAS)
print("LASSO REGRESSION METRICS")
print("R^2: ", R2_score)
print("MAE: ", metrics.mean_absolute_error(Y_test, Y_pred_LAS))
print("MSE: ", metrics.mean_squared_error(Y_test, Y_pred_LAS))
print("RMSE: ", np.sqrt(metrics.mean_squared_error(Y_test, Y_pred_LAS)))

R2_score = metrics.r2_score(Y_test, Y_pred_Ridge)
print("RIDGE REGRESSION METRICS")
print("R^2: ", R2_score)
print("MAE: ", metrics.mean_absolute_error(Y_test, Y_pred_Ridge))
print("MSE: ", metrics.mean_squared_error(Y_test, Y_pred_Ridge))
print("RMSE: ", np.sqrt(metrics.mean_squared_error(Y_test, Y_pred_Ridge)))

"""Подбор параметров"""

from sklearn.linear_model import RidgeCV

#Lasso Cross validation
ridge_cv = RidgeCV(alphas = [0.000001, 0.0001, 0.001, 0.005, 0.01, 0.05,  0.1, 0.2, 0.3, 0.4, 0.5, 1, 2, 3, 100]).fit(X_train, Y_train)
y_pred_ridgeCV = ridge_cv.predict(X_test)
#выведем результаты
reg_score_lr = ridge_cv.score(X_test, Y_test)
print("The test score for ridge model is {}".format(reg_score_lr))

from sklearn.linear_model import LassoCV

#Lasso Cross validation
lasso_cv = LassoCV(alphas = [0.0000000000000000001, 0.0000000000001, 0.00000000001, 0.000000001, 0.0000001, 0.00001, 0.000001, 0.0001, 0.001, 0.0015, 0.0002, 0.003, 0.004, 0.005, 0.01, 0.02, 0.03, 0.04, 0.042, 0.044, 0.046, 0.048,  0.05,  0.1, 0.2, 0.3, 0.4, 0.5, 1, 2, 3, 10, 15, 20, 100, 10000], cv = 100, random_state = 2, max_iter = 10000).fit(X_train, Y_train)
y_pred_lassoCV = lasso_cv.predict(X_test)
#выведем результаты
reg_score_lasso = lasso_cv.score(X_test, Y_test)
print("The test score for lasso model is {}".format(reg_score_lasso))

"""По итогу, значение у Ridge регрессии увеличилось незначительно, у Lasso регрессии подобрать параметры лучше - не получилось"""